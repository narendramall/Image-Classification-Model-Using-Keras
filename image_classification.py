# -*- coding: utf-8 -*-
"""Image-Classification-Fashion-MNIST.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1vsl8F4S430TBSQpNJrBTnNPBAaTGBRsL
"""

import tensorflow as tf
from tensorflow import keras

import numpy as np
import matplotlib.pyplot as plt

print(tf.__version__)

fashion_mnist= keras.datasets.fashion_mnist

(train_images,train_labels),(test_images,test_labels)= fashion_mnist.load_data()

train_images.shape

train_labels.shape

train_labels[5]

train_labels

test_images.shape

img=test_images[0]
img.shape

print(img)

plt.figure()
plt.imshow(train_images[0])
plt.colorbar()
plt.grid(False)
plt.show()

"""In the above figue we can see that image pixel value fall in the range of 0 to 255

So we have to scale it into 0-1 range
before feeding to NN model
"""

# here training and testing data should be process in same manner

train_images=train_images/255.0

test_images= test_images/255.0

class_names = ['T-shirt/top','Trouser','Pullover','Dress','Coat',
               'Sandal','Shirt','Sneaker','Bag','Ankle boot']
# now we are going to show the first 25 images from the training set


plt.figure(figsize=(10,10))
for i in range(25):
  plt.subplot(5,5,i+1)
  plt.xticks([])
  plt.yticks([])
  plt.grid(False)
  plt.imshow(train_images[i],cmap=plt.cm.binary)
  plt.xlabel(class_names[train_labels[i]])
plt.show()

# Now lets setup layer first

model = keras.Sequential([
    keras.layers.Flatten(input_shape=(28,28)), 
    keras.layers.Dense(128,activation=tf.nn.relu),
    keras.layers.Dense(10, activation= tf.nn.softmax)                         
])
# here we are using flatten to make 2D data to 1D
# here first dense layer has 128 neuron or node and second one has contain 10 node

"""Compile the Model So that our model will get necessary setting like optimiser, loss function, accuracy...

- Here loss function will check how accurate the model is, and we want to minimize the loss function to see that model is in right direction

- Optimizer use to update the model in right direction
"""

model.compile(optimizer='adam',
              loss='sparse_categorical_crossentropy',
              metrics= ['accuracy'])

# Fit the Model

model.fit(train_images,train_labels,epochs=10)

# Check the model on test data

test_loss, test_acc=model.evaluate(test_images, test_labels)

print('Test Accuracy', test_acc)

"""**Here we can see that accuracy decreased on test data. So it simply means that overfitting occur on the training data.**

At the time of overfitting machine learning model perform worse on a new data than on the training data
"""

predictions = model.predict(test_images)

predictions[0]

"""The above values are confidence value corresponding to each class(i.e. b/w 0-9), here we can see for confidence value for class 9 is max so prediction will be 9.

Let's check it...
"""

np.argmax(predictions[0])

test_labels[0]

"""We got the same answer right!!!

We can make graph to look at the whole 10 channels

## Plotting of test image along with its confidence
"""

def plot_image(i,predictions_array,true_labels,img):
  predictions_array, true_label, img=predictions_array[i], true_labels[i], img[i]
  plt.grid(False)
  plt.xticks([])
  plt.yticks([])
  
  plt.imshow(img,cmap=plt.cm.binary)

  predicted_label=np.argmax(predictions_array)
  if(predicted_label==true_label):
    color = 'blue'
  else:
    color = 'red'
  plt.xlabel("{} {:2.0f}% ({})".format(class_names[predicted_label],100*np.max(predictions_array),
                                       class_names[true_label]),
                                       color = color ) 



def plot_value_array(i,predictions_array,true_label):
  predictions_array, true_label=predictions_array[i], true_label[i]
  plt.grid(False)
  plt.xticks([])
  plt.yticks([])
  thisplot = plt.bar(range(10), predictions_array, color='#777777')
  plt.ylim([0,1])
  predicted_label = np.argmax(predictions_array)

  thisplot[predicted_label].set_color('red')
  thisplot[true_label].set_color('green')

"""**Let's check above plot with first test image**"""

i=0
plt.figure(figsize=(6,3))
plt.subplot(1,2,1)
plot_image(i,predictions, test_labels, test_images)
plt.subplot(1,2,2)
plot_value_array(i, predictions, test_labels)
plt.show()

# lets look at the 12th indexed test image

i=12
plt.figure(figsize=(6,3))
plt.subplot(1,2,1)
plot_image(i,predictions, test_labels, test_images)
plt.subplot(1,2,2)
plot_value_array(i, predictions, test_labels)
plt.show()

"""In the above plot we can see our model have predicted Ankle boot with 98% confidence which is Sneaker"""

i=19
plt.figure(figsize=(6,3))
plt.subplot(1,2,1)
plot_image(i,predictions, test_labels, test_images)
plt.subplot(1,2,2)
plot_value_array(i, predictions, test_labels)
plt.show()

np.argmax(predictions[19])

num_rows = 5
num_cols = 3
num_images = num_rows*num_cols
plt.figure(figsize=(2*2*num_cols,2*num_rows))
for i in range(num_images):
  plt.subplot(num_rows,2*num_cols, 2*i+1)
  plot_image(i,predictions,test_labels, test_images)
  plt.subplot(num_rows,2*num_cols,2*i+2)
  plot_value_array(i, predictions, test_labels)
plt.show()

"""**Now lets make a prediction about single image (which we will provide as input)**"""

img = test_images[0] # here we cant predit with 1 value having it as 2D array
# we need to convert it to 3D (as it was was 3D in test_images first axis was for no. of image)
print(img.shape)

img = (np.expand_dims(img,0)) # here this is expanding at 0th position by 1 axis

print(img.shape)

predictions_single = model.predict(img)

print(predictions_single)

# print prediction class
print(np.argmax(predictions_single))

# Now compare with the actual label
print(test_labels[0])

"""That the same, Is it not fantastic!!!"""

# Now plot the value array of our only predictions

plot_value_array(0, predictions_single, test_labels)
_=plt.xticks(range(10),class_names, rotation=45)

